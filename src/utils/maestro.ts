import * as yaml from 'js-yaml'
import { readFile, writeFile, access } from 'fs/promises'
import path from 'path'
import { MaestroConfig, validateMaestroConfig as validateSchema } from '../schemas/maestro.js'
import chalk from 'chalk'

// MAESTRO.yml file operations

const MAESTRO_FILE = 'MAESTRO.yml'

/**
 * Check if MAESTRO.yml exists in the current directory
 */
export async function maestroExists(): Promise<boolean> {
  try {
    await access(MAESTRO_FILE)
    return true
  } catch {
    return false
  }
}

/**
 * Load and parse MAESTRO.yml
 */
export async function loadMaestroConfig(): Promise<MaestroConfig | null> {
  try {
    await access(MAESTRO_FILE)
    const content = await readFile(MAESTRO_FILE, 'utf8')
    const rawConfig = yaml.load(content)
    
    if (!rawConfig) {
      return null
    }
    
    return validateSchema(rawConfig)
  } catch (error: any) {
    // File doesn't exist
    if (error?.code === 'ENOENT') {
      return null
    }
    
    // YAML parsing or validation error
    if (error instanceof Error) {
      throw new Error(`Failed to load MAESTRO.yml: ${error.message}`)
    }
    throw error
  }
}

/**
 * Save configuration to MAESTRO.yml
 */
export async function saveMaestroConfig(config: MaestroConfig): Promise<void> {
  try {
    // Validate before saving
    validateSchema(config)
    
    const yamlContent = yaml.dump(config, {
      indent: 2,
      lineWidth: 120,
      noRefs: true,
      sortKeys: false,
      quotingType: '"',
      forceQuotes: false,
    })
    
    await writeFile(MAESTRO_FILE, yamlContent, 'utf8')
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to save MAESTRO.yml: ${error.message}`)
    }
    throw error
  }
}

/**
 * Generate a default MAESTRO.yml template
 */
export function generateDefaultMaestroConfig(): MaestroConfig {
  const now = new Date().toISOString()
  
  return {
    version: '1.0',
    created: now,
    description: 'Orchestration plan generated by Maestro',
    orchestra: [],
    settings: {
      parallel_creation: true,
      auto_install_deps: true,
      claude_md_mode: 'split',
      base_branch: 'main',
    },
  }
}

/**
 * Validate feature dependencies
 */
export function validateDependencies(config: MaestroConfig): { valid: boolean; errors: string[] } {
  const errors: string[] = []
  const featureNames = new Set(config.orchestra.map(f => f.feature))
  
  for (const feature of config.orchestra) {
    if (feature.dependencies) {
      for (const dep of feature.dependencies) {
        if (!featureNames.has(dep)) {
          errors.push(`Feature "${feature.feature}" depends on unknown feature "${dep}"`)
        }
      }
    }
  }
  
  // Check for circular dependencies
  const visited = new Set<string>()
  const recursionStack = new Set<string>()
  
  function hasCycle(feature: string): boolean {
    visited.add(feature)
    recursionStack.add(feature)
    
    const featureConfig = config.orchestra.find(f => f.feature === feature)
    if (featureConfig?.dependencies) {
      for (const dep of featureConfig.dependencies) {
        if (!visited.has(dep)) {
          if (hasCycle(dep)) return true
        } else if (recursionStack.has(dep)) {
          return true
        }
      }
    }
    
    recursionStack.delete(feature)
    return false
  }
  
  for (const feature of config.orchestra) {
    if (!visited.has(feature.feature)) {
      if (hasCycle(feature.feature)) {
        errors.push(`Circular dependency detected involving "${feature.feature}"`)
      }
    }
  }
  
  return {
    valid: errors.length === 0,
    errors,
  }
}

/**
 * Get features in dependency order
 */
export function getFeatureOrder(config: MaestroConfig): string[] {
  const order: string[] = []
  const visited = new Set<string>()
  
  function visit(featureName: string) {
    if (visited.has(featureName)) return
    
    const feature = config.orchestra.find(f => f.feature === featureName)
    if (!feature) return
    
    // Visit dependencies first
    if (feature.dependencies) {
      for (const dep of feature.dependencies) {
        visit(dep)
      }
    }
    
    visited.add(featureName)
    order.push(featureName)
  }
  
  // Visit all features
  for (const feature of config.orchestra) {
    visit(feature.feature)
  }
  
  return order
}

/**
 * Validate maestro configuration - wrapper for schema validation
 */
export function validateMaestroConfig(config: any): boolean {
  try {
    validateSchema(config)
    return true
  } catch {
    return false
  }
}

/**
 * Resolve feature dependencies
 */
export function resolveDependencies(features: string[], config: MaestroConfig): string[] {
  const resolved: string[] = []
  const visiting = new Set<string>()
  const visited = new Set<string>()
  
  const featureMap = new Map(config.orchestra.map(f => [f.feature, f]))
  
  function visit(featureName: string): void {
    if (visited.has(featureName)) return
    if (visiting.has(featureName)) {
      throw new Error(`Circular dependency detected: ${featureName}`)
    }
    
    const feature = featureMap.get(featureName)
    if (!feature) return // Skip unknown dependencies
    
    visiting.add(featureName)
    
    if (feature.dependencies) {
      for (const dep of feature.dependencies) {
        visit(dep)
      }
    }
    
    visiting.delete(featureName)
    visited.add(featureName)
    resolved.push(featureName)
  }
  
  for (const featureName of features) {
    visit(featureName)
  }
  
  return resolved
}

/**
 * Display orchestration summary
 */
export function displayOrchestrationSummary(config: MaestroConfig): void {
  console.log(chalk.cyan.bold('\nüéº Orchestration Plan Summary\n'))
  
  console.log(chalk.gray(`Version: ${config.version}`))
  console.log(chalk.gray(`Created: ${config.created}`))
  if (config.description) {
    console.log(chalk.gray(`Description: ${config.description}`))
  }
  
  console.log(chalk.cyan(`\nüìã Features (${config.orchestra.length}):\n`))
  
  for (const feature of config.orchestra) {
    console.log(chalk.green(`  ‚Ä¢ ${feature.feature}`))
    console.log(chalk.gray(`    ${feature.description}`))
    console.log(chalk.gray(`    Sessions: ${feature.sessions.length}, Total panes: ${feature.sessions.reduce((sum, s) => sum + s.panes, 0)}`))
    
    if (feature.dependencies && feature.dependencies.length > 0) {
      console.log(chalk.yellow(`    Dependencies: ${feature.dependencies.join(', ')}`))
    }
    
    if (feature.agents && feature.agents.length > 0) {
      console.log(chalk.blue(`    Agents: ${feature.agents.join(', ')}`))
    }
  }
  
  if (config.settings) {
    console.log(chalk.cyan('\n‚öôÔ∏è  Settings:'))
    console.log(chalk.gray(`  Parallel creation: ${config.settings.parallel_creation}`))
    console.log(chalk.gray(`  Auto install deps: ${config.settings.auto_install_deps}`))
    console.log(chalk.gray(`  Claude MD mode: ${config.settings.claude_md_mode}`))
    console.log(chalk.gray(`  Base branch: ${config.settings.base_branch}`))
  }
}