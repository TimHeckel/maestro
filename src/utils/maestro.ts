import { readFile, writeFile } from 'fs/promises'
import path from 'path'
import { ConfigManager } from '../core/config.js'
import { Config } from '../core/config.js'
import chalk from 'chalk'

// Orchestration operations using .maestro.json

/**
 * Check if orchestration plan exists in .maestro.json
 */
export async function maestroExists(): Promise<boolean> {
  try {
    const configManager = new ConfigManager()
    await configManager.loadProjectConfig()
    const config = configManager.getAll()
    return config?.orchestration !== undefined && 
           config.orchestration.features !== undefined &&
           config.orchestration.features.length > 0
  } catch {
    return false
  }
}

/**
 * Load orchestration plan from .maestro.json
 */
export async function loadMaestroConfig(): Promise<Config['orchestration'] | null> {
  try {
    const configManager = new ConfigManager()
    await configManager.loadProjectConfig()
    const config = configManager.getAll()
    return config?.orchestration || null
  } catch (error: any) {
    if (error instanceof Error) {
      throw new Error(`Failed to load orchestration plan: ${error.message}`)
    }
    throw error
  }
}

/**
 * Save orchestration plan to .maestro.json
 */
export async function saveMaestroConfig(orchestration: Config['orchestration']): Promise<void> {
  try {
    const configManager = new ConfigManager()
    await configManager.loadProjectConfig()
    
    // Save orchestration to project config
    await configManager.setProjectConfigValue('orchestration', orchestration)
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to save orchestration plan: ${error.message}`)
    }
    throw error
  }
}

/**
 * Generate a default orchestration template
 */
export function generateDefaultMaestroConfig(): Config['orchestration'] {
  const now = new Date().toISOString()
  
  return {
    version: '1.0',
    created: now,
    description: 'Orchestration plan generated by Maestro',
    features: [],
    settings: {
      parallel: true,
      autoAttach: false,
    },
  }
}

/**
 * Validate orchestration dependencies
 */
export function validateDependencies(orchestration: Config['orchestration']): { valid: boolean; errors: string[] } {
  const errors: string[] = []
  
  if (!orchestration?.features) {
    return { valid: true, errors: [] }
  }
  
  const featureNames = new Set(orchestration.features.map(f => f.name))
  
  for (const feature of orchestration.features) {
    if (feature.dependencies) {
      for (const dep of feature.dependencies) {
        if (!featureNames.has(dep)) {
          errors.push(`Feature "${feature.name}" depends on unknown feature "${dep}"`)
        }
      }
    }
  }
  
  // Check for circular dependencies
  const visited = new Set<string>()
  const recursionStack = new Set<string>()
  
  function hasCycle(featureName: string): boolean {
    visited.add(featureName)
    recursionStack.add(featureName)
    
    const feature = orchestration.features?.find(f => f.name === featureName)
    if (feature?.dependencies) {
      for (const dep of feature.dependencies) {
        if (!visited.has(dep)) {
          if (hasCycle(dep)) return true
        } else if (recursionStack.has(dep)) {
          errors.push(`Circular dependency detected: ${featureName} -> ${dep}`)
          return true
        }
      }
    }
    
    recursionStack.delete(featureName)
    return false
  }
  
  for (const feature of orchestration.features) {
    if (!visited.has(feature.name)) {
      hasCycle(feature.name)
    }
  }
  
  return { valid: errors.length === 0, errors }
}

/**
 * Validate maestro configuration - wrapper for validation
 */
export function validateMaestroConfig(config: any): boolean {
  try {
    // Basic structure validation
    if (!config?.features || !Array.isArray(config.features)) {
      return false
    }
    
    // Validate each feature
    for (const feature of config.features) {
      if (!feature.name || !feature.description) {
        return false
      }
      
      // Validate sessions if present
      if (feature.sessions) {
        for (const session of feature.sessions) {
          if (!session.name || !session.panes || session.panes < 1 || session.panes > 30) {
            return false
          }
        }
      }
    }
    
    return true
  } catch {
    return false
  }
}

/**
 * Resolve feature dependencies
 */
export function resolveDependencies(features: string[], orchestration: Config['orchestration']): string[] {
  if (!orchestration?.features) {
    return features
  }
  
  const resolved: string[] = []
  const visiting = new Set<string>()
  const visited = new Set<string>()
  
  const featureMap = new Map(orchestration.features.map(f => [f.name, f]))
  
  function visit(featureName: string): void {
    if (visited.has(featureName)) return
    if (visiting.has(featureName)) {
      throw new Error(`Circular dependency detected: ${featureName}`)
    }
    
    const feature = featureMap.get(featureName)
    if (!feature) return // Skip unknown dependencies
    
    visiting.add(featureName)
    
    if (feature.dependencies) {
      for (const dep of feature.dependencies) {
        visit(dep)
      }
    }
    
    visiting.delete(featureName)
    visited.add(featureName)
    resolved.push(featureName)
  }
  
  for (const featureName of features) {
    visit(featureName)
  }
  
  return resolved
}

/**
 * Get topological order of features based on dependencies
 */
export function getTopologicalOrder(orchestration: Config['orchestration']): string[] {
  if (!orchestration?.features) {
    return []
  }
  
  const order: string[] = []
  const visited = new Set<string>()
  const featureMap = new Map(orchestration.features.map(f => [f.name, f]))
  
  function visit(featureName: string): void {
    if (visited.has(featureName)) return
    
    const feature = featureMap.get(featureName)
    if (!feature) return
    
    // Visit dependencies first
    if (feature.dependencies) {
      for (const dep of feature.dependencies) {
        visit(dep)
      }
    }
    
    visited.add(featureName)
    order.push(featureName)
  }
  
  // Visit all features
  for (const feature of orchestration.features) {
    visit(feature.name)
  }
  
  return order
}

/**
 * Display orchestration summary
 */
export function displayOrchestrationSummary(orchestration: Config['orchestration']): void {
  if (!orchestration) {
    console.log(chalk.yellow('No orchestration plan found'))
    return
  }
  
  console.log(chalk.cyan.bold('\nüéº Orchestration Plan Summary\n'))
  
  console.log(chalk.gray(`Version: ${orchestration.version}`))
  if (orchestration.created) {
    console.log(chalk.gray(`Created: ${orchestration.created}`))
  }
  if (orchestration.description) {
    console.log(chalk.gray(`Description: ${orchestration.description}`))
  }
  
  if (orchestration.features && orchestration.features.length > 0) {
    console.log(chalk.cyan(`\nüìã Features (${orchestration.features.length}):\n`))
    
    for (const feature of orchestration.features) {
      console.log(chalk.green(`  ‚Ä¢ ${feature.name}`))
      console.log(chalk.gray(`    ${feature.description}`))
      
      if (feature.sessions && feature.sessions.length > 0) {
        const totalPanes = feature.sessions.reduce((sum, s) => sum + s.panes, 0)
        console.log(chalk.gray(`    Sessions: ${feature.sessions.length}, Total panes: ${totalPanes}`))
      }
      
      if (feature.dependencies && feature.dependencies.length > 0) {
        console.log(chalk.yellow(`    Dependencies: ${feature.dependencies.join(', ')}`))
      }
      
      if (feature.agents && feature.agents.length > 0) {
        console.log(chalk.blue(`    Agents: ${feature.agents.join(', ')}`))
      }
    }
  } else {
    console.log(chalk.gray('No features defined yet'))
  }
  
  if (orchestration.settings) {
    console.log(chalk.cyan('\n‚öôÔ∏è  Settings:'))
    console.log(chalk.gray(`  Parallel creation: ${orchestration.settings.parallel}`))
    console.log(chalk.gray(`  Auto attach: ${orchestration.settings.autoAttach}`))
  }
}

// Re-export types for compatibility
export type MaestroConfig = Config['orchestration']
export type FeatureConfig = NonNullable<Config['orchestration']>['features'][0]